// DecisionTree.java
public class DecisionTree_alpha {
    // Node class representing each node in the decision tree
    public static class Node {
        String feature;
        int threshold;
        String trueBranch;
        String falseBranch;

        // Constructor to initialize a node with features and thresholds
        public Node(String feature, int threshold) {
            this.feature = feature;
            this.threshold = threshold;
        }

        // Constructor to initialize a node with additional attributes
        public Node(String feature, int threshold, String trueBranch, String falseBranch) {
            this.feature = feature;
            this.threshold = threshold;
            this.trueBranch = trueBranch;
            this.falseBranch = falseBranch;
        }
    }

    // Root of the decision tree
    private static Node root;

    // Method to calculate the attribute count at a given node
    public static int getAttributeCount(Node node) {
        if (node.getTrueBranch() == null && node.getFalseBranch() == null) {
            return 0;
        } else if (node.getTrueBranch() != null && node.getFalseBranch() == null) {
            return 1 + getAttributeCount(node.getTrueBranch());
        } else if (node.getTrueBranch() == null && node.getFalseBranch() != null) {
            return 1 + getAttributeCount(node.getFalseBranch());
        } else {
            return 2; // Leaf Node
        }
    }

    // Method to calculate the threshold value at a given node
    public static int getThreshold(Map<String, String> input) {
        if (root == null) {
            buildDecisionTree();
        }

        Node currentNode = root;
        int i = 0;
        while (i < currentNode.getAttributeCount()) {
            if (input.containsKey(currentNode.feature)) {
                if (Integer.parseInt(input.get(currentNode.feature)) >= currentNode.threshold) {
                    currentNode = currentNode.getTrueBranch();
                } else {
                    currentNode = currentNode.getFalseBranch();
                }
            } else {
                return i; // Leaf Node
            }
            i++;
        }

        throw new IllegalArgumentException("Invalid input");
    }

    // Method to build the decision tree from a given dataset
    private static void buildDecisionTree() {
        Map<String, Map<String, String>> data = new HashMap<>();
        for (String[] row : trainingData) {
            data.computeIfAbsent(row[0], k -> new HashMap<>()).put(row[1], row[2]);
        }

        // Find the root node
        Node rootNode = findRoot(data);
        root = createTree(rootNode, data);
    }

    // Method to find the root node based on the number of features in the dataset
    private static Node findRoot(Map<String, Map<String, String>> data) {
        int attributeCount = 0;
        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            attributeCount++;
            if (attributeCount == 1 || (attributeCount > 3 && random.nextDouble() < 0.5)) {
                return new Node(
                        null,
                        Integer.MAX_VALUE, // No threshold value for leaf nodes
                        "Leaf Node: " + entry.getKey(),
                        "Leaf Node: " + entry.getValue().keySet().iterator().next());
            }
        }

        throw new IllegalArgumentException("Invalid dataset");
    }

    // Method to create the decision tree based on a given node and its corresponding data
    private static Node createTree(Node node, Map<String, Map<String, String>> data) {
        if (data.isEmpty()) {
            return null; // No more attributes to split
        } else if (node.getAttributeCount() == 0) {
            return new Node(
                    null,
                    Integer.MAX_VALUE,
                    "Leaf Node: " + node.feature,
                    getPrediction(node, data));
        }

        String bestFeature = findBestSplit(data);
        int threshold = findThresholdValue(data, bestFeature);

        // Split the dataset based on the chosen attribute and threshold value
        Map<String, Map<String, String>> leftData = new HashMap<>();
        Map<String, Map<String, String>> rightData = new HashMap<>();
        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            if ((entry.getKey().equals(bestFeature) && Integer.parseInt(entry.getValue().get(bestFeature)) <= threshold) ||
                    (bestFeature == null && Integer.parseInt(entry.getValue().keySet().iterator().next()) <= threshold)) {
                leftData.computeIfAbsent(entry.getKey(), k -> new HashMap<>()).putAll(entry.getValue());
            } else {
                rightData.computeIfAbsent(entry.getKey(), k -> new HashMap<>()).putAll(entry.getValue());
            }
        }

        // Recursively build the left and right subtrees
        Node leftBranch = createTree(new Node(bestFeature, threshold), leftData);
        Node rightBranch = createTree(new Node(null, Integer.MAX_VALUE), rightData);

        return new Node(
                bestFeature,
                threshold,
                leftBranch == null ? "Leaf Node: 0" : leftBranch.feature,
                rightBranch == null ? "Leaf Node: 1" : rightBranch.feature);
    }

    // Method to find the best attribute for splitting based on a given dataset and its attributes
    private static String findBestSplit(Map<String, Map<String, String>> data) {
        int maxGain = Integer.MIN_VALUE;
        String bestFeature = null;

        for (String feature : data.keySet()) {
            // Calculate the gain at each attribute
            double gain = calculateGain(data);
            if (gain > maxGain) {
                maxGain = gain;
                bestFeature = feature;
            }
        }

        return bestFeature;
    }

    // Method to find the threshold value based on a given dataset and its corresponding values for an attribute
    private static int findThresholdValue(Map<String, Map<String, String>> data, String attribute) {
        int min = Integer.MAX_VALUE;
        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            if (!entry.getKey().equals(attribute)) {
                continue;
            }

            // Find the minimum value among all instances with this attribute
            int threshold = Integer.MAX_VALUE;
            for (Map.Entry<String, Map<String, String>> innerEntry : entry.getValue().entrySet()) {
                if (innerEntry.getKey().equals(attribute)) {
                    continue;
                }

                // If the value is less than the current threshold, update it
                if (Integer.parseInt(innerEntry.getValue().get(innerEntry.getKey())) < threshold) {
                    threshold = Integer.parseInt(innerEntry.getValue().get(innerEntry.getKey()));
                }
            }

            // Update the minimum value for this attribute
            if (threshold < min) {
                min = threshold;
            }
        }

        return min;
    }

    // Method to calculate the information gain at each attribute based on a given dataset and its attributes
    private static double calculateGain(Map<String, Map<String, String>> data) {
        int totalEntropy = 0;
        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            // Calculate the entropy of each instance based on the selected attribute
            int numInstances = Integer.parseInt(entry.getValue().keySet().iterator().next());
            double probability = numInstances / (double) data.size();

            if (probability == 0) {
                probability = 1;
            }

            // Calculate the entropy of each instance
            double entropy = -probability * Math.log2(probability) - (1 - probability) * Math.log2((1 - probability));
            totalEntropy += numInstances / data.size() * entropy;
        }

        return entropy - totalEntropy;
    }

    // Method to calculate the prediction for a given node and its corresponding dataset based on the number of instances in each leaf node
    private static String getPrediction(Node node, Map<String, Map<String, String>> data) {
        if (node.getAttributeCount() == 0) {
            return data.keySet().iterator().next();
        } else {
            int count = 0;
            for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
                if ((entry.getKey().equals(node.feature) && Integer.parseInt(entry.getValue().get(node.feature)) <= node.threshold) ||
                        (node.feature == null && Integer.parseInt(entry.getValue().keySet().iterator().next()) <= node.threshold)) {
                    count++;
                }
            }

            return count == data.size() ? "Leaf Node: 0" : "Leaf Node: 1";
        }
    }

    // Method to split the dataset based on a given attribute and threshold value
    private static Map<String, Map<String, String>> splitDataset(Map<String, Map<String, String>> data, Node node) {
        int bestAttribute = node.feature;

        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            if ((entry.getKey().equals(bestAttribute) && Integer.parseInt(entry.getValue().get(bestAttribute)) <= node.threshold) ||
                    (node.feature == null && Integer.parseInt(entry.getValue().keySet().iterator().next()) <= node.threshold)) {
                entry.remove(bestAttribute);
            }
        }

        return data;
    }

    // Method to find the number of instances in each leaf node based on a given dataset and its corresponding values for an attribute
    private static Map<String, String> calculateLeafNodes(Map<String, Map<String, String>> data) {
        int totalInstances = 0;
        for (Map.Entry<String, Map<String, String>> entry : data.entrySet()) {
            // Calculate the number of instances in each leaf node based on the selected attribute and threshold value
            if (entry.getKey().equals("Leaf Node: 0")) {
                totalInstances += Integer.parseInt(entry.getValue().keySet().iterator().next());
            } else if (entry.getKey().equals("Leaf Node: 1")) {
                totalInstances -= Integer.parseInt(entry.getValue().keySet().iterator().next());
            }
        }

        Map<String, String> leafNodes = new HashMap<>();
        for (int i = 0; i < totalInstances / 2; i++) {
            leafNodes.put("Leaf Node: 0", "0");
        }

        if (totalInstances % 2 != 0) {
            leafNodes.put("Leaf Node: 1", String.valueOf(totalInstances - 1));
        } else {
            for (int i = 0; i < totalInstances / 2; i++) {
                leafNodes.put("Leaf Node: 1", "1");
            }
        }

        return leafNodes;
    }

    // Main method to test the implementation of decision tree learning using only attribute selection and no feature engineering
    public static void main(String[] args) {
        Map<String, Map<String, String>> dataset = new HashMap<>();
        dataset.put("A", Map.of("B", "1"));
        dataset.put("B", Map.of("C", "0"));
        dataset.put("C", Map.of("D", "1"));
        dataset.put("D", Map.of("E", "1"));
        dataset.put("E", Map.of("F", "0"));

        Node rootNode = new Node(dataset, null);

        DecisionTreeDecision tree = new DecisionTreeDecision(rootNode);
        tree.buildTree();

        System.out.println("Prediction for A: " + tree.predict("A"));
        System.out.println("Prediction for B: " + tree.predict("B"));
        System.out.println("Prediction for C: " + tree.predict("C"));
        System.out.println("Prediction for D: " + tree.predict("D"));
        System.out.println("Prediction for E: " + tree.predict("E"));
    }
}

class Node {
    Map<String, Map<String, String>> dataset;
    Node parentNode;
    int threshold;
    boolean isLeaf;

    public Node(Map<String, Map<String, String>> dataset, Node parent) {
        this.dataset = dataset;
        this.parentNode = parent;

        if (this.dataset == null || this.dataset.isEmpty()) {
            this.isLeaf = true;
        } else {
            calculateThreshold();
        }
    }

    private void calculateThreshold() {
        Map<String, Integer> counts = new HashMap<>();
        for (Map.Entry<String, Map<String, String>> entry : dataset.entrySet()) {
            int count = 0;
            if (parentNode != null) {
                count += parentNode.dataset.get(entry.getKey()).size() + 1; // +1 to include the current node
            } else {
                for (Map.Entry<String, Integer> entry : dataset.keySet()) {
                    if (!entry.equals(entry.getKey())) {
                        count++;
                    }
                }
            }

            counts.put(entry.getKey(), count);
        }

        int maxCount = 0;
        String mostFrequentAttribute = null;

        for (Map.Entry<String, Integer> entry : counts.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                mostFrequentAttribute = entry.getKey();
            }
        }

        threshold = dataset.keySet().contains(mostFrequentAttribute) ? Integer.MAX_VALUE : 0;
    }
}

class DecisionTreeDecision {
    Node rootNode;

    public DecisionTreeDecision(Node rootNode) {
        this.rootNode = rootNode;
    }

    public void buildTree() {
        if (rootNode == null || rootNode.isLeaf) {
            return;
        }

        Map<String, Map<String, String>> dataset = new HashMap<>();
        for (Map.Entry<String, Map<String, String>> entry : rootNode.dataset.entrySet()) {
            if (rootNode.parentNode != null && !entry.getKey().equals(rootNode.parentNode.dataset.keySet().iterator().next())) {
                dataset.put("A", entry.getValue());
            } else {
                dataset.put("B", entry.getValue());
            }
        }

        rootNode = new Node(dataset, rootNode);
    }

    public String predict(String attribute) {
        if (rootNode == null || rootNode.isLeaf) {
            return rootNode.isLeaf ? "0" : "1";
        } else {
            Map<String, Map<String, String>> dataset = new HashMap<>();
            for (Map.Entry<String, Map<String, String>> entry : rootNode.dataset.entrySet()) {
                if (rootNode.parentNode != null && !entry.getKey().equals(rootNode.parentNode.dataset.keySet().iterator().next())) {
                    dataset.put("A", entry.getValue());
                } else {
                    dataset.put("B", entry.getValue());
                }
            }

            return predict(attribute, rootNode, dataset);
        }
    }

    private String predict(String attribute, Node node, Map<String, Map<String, String>> dataset) {
        if (node == null || node.isLeaf) {
            return node.isLeaf ? "0" : "1";
        } else {
            int count = 0;
            for (Map.Entry<String, Map<String, String>> entry : dataset.entrySet()) {
                if (entry.getValue().containsKey(attribute)) {
                    count++;
                }
            }

            return predictAttribute(node, attribute, count);
        }
    }

    private String predictAttribute(Node node, String attribute, int count) {
        if (node == null || node.isLeaf) {
            return node.isLeaf ? "0" : "1";
        } else if (count < node.threshold &&!node.parentNode.dataset.containsKey(attribute)) {
            return predictAttribute(node.parentNode, attribute, count);
        } else if ((count >= node.threshold) && (node.parentNode == null ||!node.parentNode.dataset.containsKey(attribute))) {
            if (count > node.parentNode.threshold) {
                return "1"; // If child is more frequent and has a higher threshold, it goes to the left branch
            } else {
                return "0"; // Otherwise, it goes to the right branch
            }
        } else if (node.parentNode == null ||!node.parentNode.dataset.containsKey(attribute)) {
            return predictAttribute(rootNode, attribute, count);
        }

        String prediction = node.isLeaf ? "0" : "1";
        int maxCount = 0;
        String mostFrequentAttribute = null;

        for (Map.Entry<String, Integer> entry : dataset.entrySet()) {
            if ((entry.getValue().containsKey(attribute) &&!node.parentNode.dataset.containsKey(attribute)) ||
                    (!entry.getValue().containsKey(attribute) && node.parentNode == null)) {
                int childCount = 0;
                for (Map.Entry<String, Integer> entry1 : dataset.entrySet()) {
                    if ((entry1.getValue().containsKey(attribute) &&!entry.getValue().containsKey(attribute)) ||
                            (!entry1.getValue().containsKey(attribute) && node.parentNode == null)) {
                        childCount++;
                    }
                }

                if (childCount > maxCount) {
                    maxCount = childCount;
                    mostFrequentAttribute = entry.getKey();
                }
            }
        }

        return prediction + mostFrequentAttribute;
    }
}